/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "interface2.h"
#include <stdlib.h>
#include <stdio.h>


// Vector para almacenar los productos registrados 
nodo_producto vectorProductos[5] = {
        {1, "Mesa", 10.0, SI},
        {2, "Carro", 20.0, SI},
        {3, "Plato", 30.0, SI}
};


// Índice para llevar cuenta de cuántos productos
int posicionProductoAregistrar=3;

// Declarar la variable global subasta_actual
nodo_subasta subasta_actual;


bool_t *
registrar_producto_2_svc(nodo_producto *argp, struct svc_req *rqstp)
{
	static bool_t  result;
	printf("Invocando a registrar producto");
	printf("\n codigo del producto %d",argp->codigoProducto);
	if(posicionProductoAregistrar<5){
		vectorProductos[posicionProductoAregistrar]=*argp;
		result=TRUE;
		posicionProductoAregistrar++;
	}
	else{
		result=FALSE;
	}

	return &result;
}

vector_productos *
listarproductosdisponiblessubastar_2_svc(void *argp, struct svc_req *rqstp)
{
	static vector_productos result;
	printf("\nInvocando a listar productos disponibles para subastar");

	int posicionResultado = 0;
    for (int i = 0; i < posicionProductoAregistrar; i++) {
        if (vectorProductos[i].estadoProd == SI) {
            result.vector_productos[posicionResultado] = vectorProductos[i];
            posicionResultado++;
        }
    }
    
    return &result;
}

bool_t *
abrircerrarsubasta_2_svc(int *argp, struct svc_req *rqstp)
{
    static bool_t result;
    printf("Invocando a abrir o cerrar subasta para producto %d\n", *argp);
    
    // Verificar si hay una subasta abierta para otro producto
    if (subasta_actual.estado == ABIERTA && subasta_actual.prod.codigoProducto != *argp) {
        printf("Ya hay una subasta abierta para otro producto, no se puede iniciar otra\n");
        result = FALSE;
        return &result;
    }
    
    // Verificar si ya existe el producto especificado
    int indiceProducto = -1;
    for (int i = 0; i <= posicionProductoAregistrar; i++) {
        if (vectorProductos[i].codigoProducto == *argp) {
            indiceProducto = i;
            break;
        }
    }
	if (indiceProducto < 0)
	{
		result = FALSE;
		return &result;
	}
    // Si ya hay una subasta abierta para el producto, cerrarla
	if (subasta_actual.estado == ABIERTA && subasta_actual.prod.codigoProducto == *argp) {
		//si se va a cerrar una subasta y ho hay comparador
		if (subasta_actual.oferta_actual.objUsuario_comprador_actual.tipo == ADMIN_C)
		{
			vectorProductos[indiceProducto].estadoProd = SI; //que vuelva a estra disponible
		}
		subasta_actual.estado = CERRADA;
		printf("Cerrando subasta para producto %d\n", subasta_actual.prod.codigoProducto);
		result = TRUE;
	}else
	{
			
		// Si la subasta existente está (cerrada o nueva)y Si el producto esta disponible para subastar
		// abrir una nueva subasta
		if ((subasta_actual.estado == CERRADA || subasta_actual.estado == NUEVA) && vectorProductos[indiceProducto].estadoProd == SI) {
			// Crear la nueva subasta
			vectorProductos[indiceProducto].estadoProd = NO; //ya no esta disponible para subastar porque ya se va a subastar
			subasta_actual.prod = vectorProductos[indiceProducto];
			subasta_actual.oferta_actual.valor = vectorProductos[indiceProducto].valor;
			subasta_actual.estado = ABIERTA;
			printf("Abriendo subasta para producto %d\n", subasta_actual.prod.codigoProducto);
			result = TRUE;
		} else {
			printf("No existe el producto especificado o ya hay una subasta cerrada para ese producto\n");
			result = FALSE;
		}
		
	}
	
    
    return &result;
}

vector_productos *
listarproductostodos_2_svc(void *argp, struct svc_req *rqstp)
{
	static vector_productos result;
    printf("Invocando a listar todos los productos\n");
    
    int posicionResultado = 0;
    for (int i = 0; i < posicionProductoAregistrar; i++) {
        result.vector_productos[posicionResultado] = vectorProductos[i];
        posicionResultado++;
    }
    
    return &result;
}

nodo_producto *
consultarproducto_2_svc(int *argp, struct svc_req *rqstp)
{
	static nodo_producto result;
	//TODO
	result.codigoProducto = -1; // Valor sentinela para indicar que no existe
	printf("Invocando a consultar producto\n");
	// Buscar el producto correspondiente y retornarlo
	for (int i = 0; i < posicionProductoAregistrar; i++) {
		if (vectorProductos[i].codigoProducto == *argp) {
			result = vectorProductos[i];
			break;
		}
	}
	return &result;
}

nodo_subasta *
consultarproductoandvaloractualsubasta_2_svc(void *argp, struct svc_req *rqstp)
{
    static nodo_subasta result;
    printf("Invocando a consultar producto y valor actual de subasta\n");
    
    // Verificar si hay una subasta abierta en este momento
    if (subasta_actual.estado == CERRADA) {
        result.prod.codigoProducto = -1; // Valor sentinela para indicar que no hay subasta abierta
    }else
	{
		// Construir el nodo_subasta con la información del producto en subasta y la oferta actual
		memcpy(&result, &subasta_actual, sizeof(nodo_subasta));
	}
	
    
    
    return &result;
}


bool_t *
ofertarproductosubasta_2_svc(oferta *argp, struct svc_req *rqstp)
{
	static bool_t result;
	printf("Invocando a ofertar producto en subasta\n");

	// Verificar si la subasta está abierta
	if (subasta_actual.estado == CERRADA) {
		result = FALSE;
	}else
	{
		// Verificar si la oferta recibida es mayor que la oferta actual
		if (argp->valor <= subasta_actual.oferta_actual.valor) {
			result = FALSE;
		}else
		{
			// Actualizar la oferta actual de la subasta
			subasta_actual.oferta_actual.valor = argp->valor;
      		subasta_actual.oferta_actual.objUsuario_comprador_actual = argp->objUsuario_comprador_actual;
			result = TRUE;
		}
	}	
	return &result;
}

